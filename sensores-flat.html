// ===================================================================
// SCRIPT ATUALIZADO PARA USAR A WEB BLUETOOTH API COM BLE E JSON
// Inclui fallback para formato CSV legado: "Nivel,Luz,ValorR"
// ===================================================================

// Elementos da UI
const connectBtn = document.getElementById("connectBtn");
const connectionStatus = document.getElementById("connectionStatus");
const dataConsole = document.getElementById("dataConsole");
const thermometerFill = document.getElementById("thermometerFill");
const thermometerBulb = document.getElementById("thermometerBulb");
const rgbData = document.getElementById("rgbData");
const rgbStatus = document.getElementById("rgbStatus");
const ldrValue = document.getElementById("ldrValue");
const ldrStatus = document.getElementById("ldrStatus");

// Novos elementos para interpretação
const interpretationText = document.getElementById("interpretationText");
const interpretationDetails = document.getElementById("interpretationDetails");
const interpretationBox = document.getElementById("interpretationBox");

// Variáveis de estado da conexão
let bleDevice;
let bleServer;

// UUIDs do Serviço e Característica definidos no código do ESP32
const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const CHARACTERISTIC_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";

// Verifica se o navegador suporta Web Bluetooth
if (!navigator.bluetooth) {
    alert("Web Bluetooth API não é suportada neste navegador! Use Chrome ou Edge.");
    connectBtn.disabled = true;
}

// Função principal de conexão/desconexão
async function handleConnection() {
    if (bleDevice && bleDevice.gatt.connected) {
        disconnect();
    } else {
        connect();
    }
}

// Função para conectar ao dispositivo BLE
async function connect() {
    try {
        console.log("=== INICIANDO CONEXÃO BLE ===");
        console.log("SERVICE_UUID:", SERVICE_UUID);
        console.log("CHARACTERISTIC_UUID:", CHARACTERISTIC_UUID);
        console.log("Navegador suporta Bluetooth:", !!navigator.bluetooth);
        
        updateConnectionStatus("Procurando...", "connecting");
        
        console.log("Chamando navigator.bluetooth.requestDevice...");
        
        // Procura por um dispositivo que anuncie o nosso serviço específico
        bleDevice = await navigator.bluetooth.requestDevice({
            filters: [{ services: [SERVICE_UUID] }],
            // optionalServices pode ser útil se o navegador exigir acesso extra
            // optionalServices: [SERVICE_UUID]
        });

        console.log("Dispositivo encontrado:", bleDevice.name);
        updateConnectionStatus("Conectando ao GATT...", "connecting");
        
        bleDevice.addEventListener("gattserverdisconnected", onDisconnected);
        console.log("Conectando ao servidor GATT...");
        bleServer = await bleDevice.gatt.connect();

        console.log("Conectado ao GATT, obtendo serviço...");
        updateConnectionStatus("Obtendo Serviço...", "connecting");
        const service = await bleServer.getPrimaryService(SERVICE_UUID);

        console.log("Serviço obtido, obtendo característica...");
        updateConnectionStatus("Obtendo Característica...", "connecting");
        const characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);

        console.log("Característica obtida, iniciando notificações...");
        updateConnectionStatus("Iniciando notificações...", "connecting");
        await characteristic.startNotifications();
        characteristic.addEventListener("characteristicvaluechanged", handleNotifications);

        console.log("=== CONEXÃO BLE ESTABELECIDA COM SUCESSO ===");
        updateConnectionStatus("Conectado", "connected");
        connectBtn.textContent = "Desconectar";

    } catch (error) {
        console.error("=== ERRO NA CONEXÃO BLE ===");
        console.error("Tipo do erro:", error.name);
        console.error("Mensagem do erro:", error.message);
        console.error("Stack trace:", error.stack);
        
        let errorMessage = "Falha na conexão: " + error.message;
        
        if (error.name === "NotFoundError") {
            errorMessage = "Dispositivo Bio-Guard não encontrado. Verifique se o ESP32 está ligado e anunciando o serviço BLE.";
        } else if (error.name === "SecurityError") {
            errorMessage = "Erro de segurança. Certifique-se de estar usando HTTPS ou localhost.";
        } else if (error.name === "NotSupportedError") {
            errorMessage = "Bluetooth não suportado neste navegador/dispositivo.";
        } else if (error.name === "NetworkError") {
            errorMessage = "Erro de rede. Verifique sua conexão Bluetooth e de internet.";
        } else if (error.name === "AbortError") {
            errorMessage = "Conexão cancelada pelo usuário.";
        } else {
            errorMessage = "Erro desconhecido: " + error.message;
        }
        updateConnectionStatus(errorMessage, "disconnected");
        console.log("Atualizando status para desconectado.");
        connectBtn.textContent = "Conectar ao Bio-Guard via Bluetooth";
    }
}

// Função para desconectar do dispositivo BLE
function disconnect() {
    if (bleDevice && bleDevice.gatt.connected) {
        console.log("Desconectando do dispositivo GATT...");
        bleDevice.gatt.disconnect();
        updateConnectionStatus("Desconectado", "disconnected");
        connectBtn.textContent = "Conectar ao Bio-Guard via Bluetooth";
        console.log("Dispositivo desconectado.");
    } else {
        console.log("Nenhum dispositivo conectado para desconectar.");
    }
}

// Evento de desconexão do GATT
function onDisconnected(event) {
    const device = event.target;
    console.log(`Dispositivo ${device.name} foi desconectado.`);
    updateConnectionStatus("Desconectado - Clique para conectar", "disconnected");
    connectBtn.textContent = "Conectar ao Bio-Guard via Bluetooth";
    // Limpar dados exibidos
    rgbData.innerHTML = `<div><strong>Contaminação:</strong> --</div><div><small>(Valor Vermelho: --)</small></div>`;
    ldrValue.textContent = `--%`;
    rgbStatus.className = "status-flat disconnected";
    rgbStatus.textContent = "Desconectado";
    ldrStatus.className = "status-flat disconnected";
    ldrStatus.textContent = "Desconectado";
    dataConsole.textContent = "Aguardando conexão...";
    updateInterpretation("Aguardando dados dos sensores para análise...", "Conecte-se ao dispositivo Bio-Guard para receber informações detalhadas sobre a qualidade da água.", "bom");
}

// Atualiza o status da conexão na UI
function updateConnectionStatus(message, statusClass) {
    connectionStatus.textContent = message;
    connectionStatus.className = `status-flat ${statusClass}`;
}

// Lida com as notificações da característica BLE
function handleNotifications(event) {
    const value = event.target.value;
    const decoder = new TextDecoder("utf-8");
    const receivedData = decoder.decode(value);
    console.log("Dados recebidos:", receivedData);
    
    // Adiciona ao console de dados
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    dataConsole.innerHTML = `[${timeString}] ${receivedData}<br>` + dataConsole.innerHTML;

    processData(receivedData);
}

// Processa os dados recebidos (tenta JSON, depois CSV)
function processData(data) {
    try {
        const jsonData = JSON.parse(data);
        console.log("Dados JSON recebidos:", jsonData);
        processDataJson(jsonData);
    } catch (e) {
        console.warn("Não é JSON válido, tentando formato CSV legado.", e);
        processDataLegacy(data);
    }
}

// Processa dados no formato JSON
function processDataJson(data) {
    const nivel = data.nivel;
    const luz = data.luz;
    const valorR = data.valorR;

    if (typeof nivel === 'number' && typeof luz === 'number' && typeof valorR === 'number') {
        updateRGB(nivel, valorR);
        updateLDR(luz);
        updateInterpretationFromData(nivel, luz);
    } else {
        console.error("Dados JSON inválidos ou incompletos:", data);
        updateInterpretation("Erro: Dados JSON incompletos ou inválidos.", "Verifique o formato dos dados enviados pelo ESP32.", "critico");
    }
}

// Processa dados no formato CSV legado
function processDataLegacy(data) {
    const parts = data.split(",");
    if (parts.length >= 3) {
        const nivel = parseFloat(parts[0]);
        const luz = parseFloat(parts[1]);
        const valorR = parseFloat(parts[2]);

        if (!isNaN(nivel) && !isNaN(luz) && !isNaN(valorR)) {
            updateRGB(nivel, valorR);
            updateLDR(luz);
            updateInterpretationFromData(nivel, luz);
        } else {
            console.error("Dados CSV inválidos (não numéricos):", data);
            updateInterpretation("Erro: Dados CSV não numéricos.", "Verifique se o ESP32 está enviando números válidos.", "critico");
        }
    } else {
        console.error("Formato CSV inválido:", data);
        updateInterpretation("Erro: Formato CSV inválido.", "Esperado 'Nivel,Luz,ValorR'.", "critico");
    }
}

// Atualiza a UI para o sensor RGB (Nível de Contaminação)
function updateRGB(nivel, valorR) {
    const fillHeight = Math.max(0, Math.min(100, nivel)); // Garante que o valor esteja entre 0 e 100
    thermometerFill.style.height = `${fillHeight}%`;
    thermometerBulb.style.backgroundColor = getColorForLevel(nivel);
    thermometerFill.style.backgroundColor = getColorForLevel(nivel);

    rgbData.innerHTML = `<div><strong>Contaminação:</strong> ${nivel.toFixed(2)}%</div><div><small>(Valor Vermelho: ${valorR})</small></div>`;
    rgbStatus.className = "status-flat connected";
    rgbStatus.textContent = "Conectado";

    // Atualiza classes de nível
    thermometerFill.classList.remove("level-baixa", "level-media", "level-alta");
    thermometerBulb.classList.remove("level-baixa", "level-media", "level-alta");
    if (nivel < 30) {
        thermometerFill.classList.add("level-baixa");
        thermometerBulb.classList.add("level-baixa");
    } else if (nivel < 70) {
        thermometerFill.classList.add("level-media");
        thermometerBulb.classList.add("level-media");
    } else {
        thermometerFill.classList.add("level-alta");
        thermometerBulb.classList.add("level-alta");
    }
}

// Retorna a cor baseada no nível de contaminação
function getColorForLevel(nivel) {
    if (nivel < 30) return "#4CAF50"; // Verde
    if (nivel < 70) return "#FF9800"; // Laranja
    return "#F44336"; // Vermelho
}

// Atualiza a UI para o sensor LDR (Luminosidade)
function updateLDR(luz) {
    const ldrPercentage = Math.max(0, Math.min(100, (luz / 4095) * 100)); // Assumindo 4095 como valor máximo do ADC
    ldrValue.textContent = `${ldrPercentage.toFixed(1)}%`;
    ldrStatus.className = "status-flat connected";
    ldrStatus.textContent = "Conectado";
}

// Função para atualizar a seção de interpretação
function updateInterpretation(text, details, status) {
    interpretationText.innerHTML = `<span class="status-indicator status-${status}"></span>${text}`;
    interpretationDetails.textContent = details;
    interpretationBox.className = `interpretation-box`; // Reset class
    if (status === "bom") {
        interpretationBox.style.borderLeftColor = "#4CAF50";
    } else if (status === "atencao") {
        interpretationBox.style.borderLeftColor = "#FF9800";
    } else if (status === "critico") {
        interpretationBox.style.borderLeftColor = "#F44336";
    }
}

// Lógica de interpretação baseada nos dados dos sensores
function updateInterpretationFromData(nivel, luz) {
    let status = "bom";
    let text = "Qualidade da água excelente.";
    let details = "Os níveis de contaminação e turbidez estão dentro dos limites ideais. O ambiente aquático está saudável.";

    if (nivel >= 70) {
        status = "critico";
        text = "Nível de contaminação crítico!";
        details = "A contaminação está muito alta. Recomenda-se ação imediata para investigar a causa e tratar a água.";
    } else if (nivel >= 30) {
        status = "atencao";
        text = "Nível de contaminação elevado.";
        details = "A contaminação está acima do ideal. Monitore de perto e considere medidas preventivas.";
    }

    // Exemplo de interpretação para LDR (turbidez)
    // Valores LDR mais baixos = mais luz = menos turbidez (água mais clara)
    // Valores LDR mais altos = menos luz = mais turbidez (água mais turva)
    const ldrThresholdHighTurbidity = 3000; // Exemplo: LDR > 3000 indica alta turbidez
    const ldrThresholdMediumTurbidity = 1500; // Exemplo: LDR > 1500 indica média turbidez

    if (luz >= ldrThresholdHighTurbidity) {
        if (status === "bom") status = "atencao"; // Se já for crítico, mantém crítico
        text = "Alta turbidez detectada!";
        details = "A intensidade de luz está baixa, indicando alta turbidez na água. Isso pode ser causado por partículas em suspensão ou algas.";
    } else if (luz >= ldrThresholdMediumTurbidity) {
        if (status === "bom") status = "atencao";
        text = "Turbidez moderada.";
        details = "A turbidez da água está moderada. Monitore para garantir que não aumente.";
    }

    updateInterpretation(text, details, status);
}

// Event Listeners
connectBtn.addEventListener("click", handleConnection);


